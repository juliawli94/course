package simpledb;

import java.util.*;

/**
 * The SymmetricHashJoin operator implements the symmetric hash join operation.
 */
public class SymmetricHashJoin extends Operator {
    private JoinPredicate pred;
    private DbIterator child1, child2;
    // private DbIterator outerChild = child1, innerChild = child2;
    private DbIterator outerChild, innerChild;
    private int outerFieldIndex, innerFieldIndex;
    private TupleDesc comboTD;
    private boolean currInnerOriginal;
    private Tuple innerTup = null;
    private int listIndex = 0;
    private ArrayList<Tuple> outputBuffer = new ArrayList<Tuple>();

    // inner table
    private HashMap<Object, ArrayList<Tuple>> leftMap = new HashMap<Object, ArrayList<Tuple>>();
    // outer table
    private HashMap<Object, ArrayList<Tuple>> rightMap = new HashMap<Object, ArrayList<Tuple>>();

     /**
     * Constructor. Accepts children to join and the predicate to join them on.
     * 
     * @param p
     *            The predicate to use to join the children
     * @param child1
     *            Iterator for the left(outer) relation to join
     * @param child2
     *            Iterator for the right(inner) relation to join
     */
    public SymmetricHashJoin(JoinPredicate p, DbIterator child1, DbIterator child2) {
        this.pred = p;
        this.child1 = child1;
        this.child2 = child2;
        this.outerChild = child1;
        this.innerChild = child2;
        comboTD = TupleDesc.merge(child1.getTupleDesc(), child2.getTupleDesc());
        this.innerFieldIndex = p.getField1();
        this.outerFieldIndex = p.getField2();
        currInnerOriginal = true;
    }

    public TupleDesc getTupleDesc() {
        return comboTD;
    }

    /**
     * Opens the iterator.
     */
    public void open() throws DbException, NoSuchElementException,
            TransactionAbortedException {
        child1.open();
        child2.open();
        super.open();

    }

    /**
     * Closes the iterator.
     */
    public void close() {
        child1.close();
        child2.close();
        super.close();
    }

    /**
     * Rewinds the iterator. You should not be calling this method for this join. 
     */
    public void rewind() throws DbException, TransactionAbortedException {
        child1.rewind();
        child2.rewind();
        this.leftMap.clear();
        this.rightMap.clear();
    }

    private Tuple combineTuples(Tuple t1, Tuple t2) {
        int td1n = t1.getTupleDesc().numFields();
        int td2n = t2.getTupleDesc().numFields();

        Tuple t = new Tuple(comboTD);
        for (int i = 0; i < td1n; i++)
            t.setField(i, t1.getField(i));
        for (int i = 0; i < td2n; i++)
            t.setField(td1n + i, t2.getField(i));
        return t;
    }

    /**
     * Fetches the next tuple generated by the join, or null if there are no 
     * more tuples.  Logically, this is the next tuple in r1 cross r2 that
     * satifies the join predicate.
     *
     * Note that the tuples returned from this particular implementation are
     * simply the concatenation of joining tuples from the left and right
     * relation.  Therefore, there will be two copies of the join attribute in
     * the results.
     *
     * For example, joining {1,2,3} on equality of the first column with {1,5,6}
     * will return {1,2,3,1,5,6}.
     */
    protected Tuple fetchNext() throws TransactionAbortedException, DbException {

        if (!outputBuffer.isEmpty()) {
            return outputBuffer.remove(0);
        }

        while (innerChild.hasNext()) {
            innerTup = innerChild.next();
            Field innerField = innerTup.getField(innerFieldIndex);

            // stream inner child into inner map
            if (leftMap.containsKey(innerField)) {
                leftMap.get(innerField).add(innerTup);
            } else {
                ArrayList<Tuple> l = new ArrayList<Tuple>();
                l.add(innerTup);
                leftMap.put(innerField, l);
            }

            // check if there are matches in the outer map
            if (rightMap.containsKey(innerField)) {
                ArrayList<Tuple> tupleList = rightMap.get(innerField);

                for (int i = 0; i < tupleList.size(); i++) {
                    Tuple outerTup = tupleList.get(i);
                    if (!currInnerOriginal) {
                        if (pred.filter(innerTup, outerTup)) {
                            outputBuffer.add(combineTuples(innerTup, outerTup));
                        }
                    } else {
                        if (pred.filter(outerTup, innerTup)) {
                            outputBuffer.add(combineTuples(outerTup, innerTup));
                        }
                    }
                }
                return outputBuffer.remove(0);
            } 
            switchRelations();
        }

        if (outerChild.hasNext()) {
            switchRelations();
            return fetchNext();
        }
        return null;
    }

    /**
     * Switches the inner and outer relation.
     */
    private void switchRelations() throws TransactionAbortedException, DbException {
        DbIterator tempChild = outerChild;
        outerChild = innerChild;
        innerChild = tempChild;

        HashMap<Object, ArrayList<Tuple>> tempMap = rightMap;
        rightMap = leftMap;
        leftMap = tempMap;

        currInnerOriginal = !currInnerOriginal;
    }

    @Override
    public DbIterator[] getChildren() {
        return new DbIterator[]{this.child1, this.child2};
    }

    @Override
    public void setChildren(DbIterator[] children) {
        this.child1 = children[0];
        this.child2 = children[1];
    }

}